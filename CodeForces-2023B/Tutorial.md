请注意，我们跳过 $b_i \leq i$ 的问题是毫无意义的，因为我们可以解决这个问题，获得分数，而下一个问题将从 $ j \lt i $ 中选出。如果我们跳过这道题，我们就得不到分数，而下一道题将从同一组题中选择，甚至从更小的题中选择。

我们还注意到，如果我们遇到的问题是 $ i $ ，而比赛早期分配给我们的最大问题编号是 $ j \geqslant b_i $ ，那么跳过该问题是没有意义的。  那么跳过这道题是没有意义的，因为跳过这道题后，我们只需解题就可以从问题 $ j $ 到达下一道题。

在这些条件下，比赛结束后分配给我们的所有问题都在问题集的某个前缀上（即从 $ 1 $ 到 $ n $ 存在某个数字 $ i $ ，这样所有数字为 $ j \leq i $ 的问题我们都收到了，而数字为 $ j \gt i $ 的问题我们没有收到）。情况确实如此；让 $ i $ 成为分配给我们的最大问题编号。在分配了这个问题后，我们不会再跳过任何问题，因为我们已经证明了这样做是无益的，也就是说，我们只会解决问题，并且会解决所有编号为 $ j \lt i $ 的问题，这些问题之前都没有被访问过。

我们的目标不是使已解决问题的总得分最大化，而是使跳过问题的总得分最小化。如果跳过一个问题，我们会受到相当于 $ a_i $ 的惩罚；如果解决了一个问题，则会受到 $ 0 $ 的惩罚。我们知道答案位于某个前缀上，因此现在我们要确定达到每个问题所需的最小惩罚。

让我们来解决下面的子问题。我们得到了相同的问题，如果我们在问题 $ i $ 中，则有以下两个选项：

- 支付罚金 $ 0 $ ，并移动到问题 $ i - 1 $ ，如果存在这样的问题的话；支付罚金 $ 0 $ ，并移动到问题 $ i - 1 $ 。  如果存在这样的问题
- 支付 $ a_i $ 的罚金并移动到问题 $ b_i $ 。  .

现在我们可以随意访问每个问题。在这种情况下，我们可以构建如下形式的加权有向图：

- 该图有 $ n $ 个顶点，每个顶点 $ i $ 对应问题 $ i $ ；
- 对于每个 $ i \gt 1 $  有一条权重为 $ 0 $ 的边从顶点 $ i $ 到顶点 $ i - 1 $ ；
  有一条权重为 $ a_i $ 的边从顶点 $ i $ 到顶点 $ b_i $ 。

因此，我们的任务就简化为找到从顶点 $ 1 $ 到每个顶点的最短距离。回想一下，最短距离保证了在到达顶点 $ i $ 的过程中，我们最多访问过每个顶点。  这意味着，如果我们在到达问题 $ i $ 时受到一定惩罚，我们可以解决前缀上直到 $ i $ （含）的所有问题，因为所有跳过问题的点数都会得到惩罚的补偿。由于我们已经知道最佳答案位于其中一个前缀上，因此我们需要知道每个前缀上问题的总分，这可以通过前缀和轻松实现。然后，从前缀总和与到达顶点 $ i $ 所需的最小惩罚之间的所有差值中，我们将选择所有问题中的最大值。  中选择最大值 $ i $ ，这就是答案。  这就是答案。

我们将使用 Dijkstra 算法在 $ O(n \log n) $ 中找到最短距离。

$ O(n) $ 中会计算前缀和。

最终渐进复杂度： $ O(n \log n) $ 。